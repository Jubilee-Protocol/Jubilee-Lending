import { expect } from "chai";
import pkg from "hardhat";
const { ethers } = pkg;

describe("JubileeLending HACKER Audit - Exploits", function () {
    let jubileeLending, collateralManager, oracleAggregator, jubl, jublBoost;
    let usdi, wbtc;
    let btcOracle;
    let owner, attacker, liquidator;

    beforeEach(async function () {
        [owner, attacker, liquidator] = await ethers.getSigners();

        const MockERC20 = await ethers.getContractFactory("MockERC20");
        usdi = await MockERC20.deploy("Jubilee USD Index", "jUSDi");
        wbtc = await MockERC20.deploy("Wrapped BTC", "wBTC");
        jubl = await MockERC20.deploy("Jubilee Token", "JUBL");

        const MockV3Aggregator = await ethers.getContractFactory("MockV3Aggregator");
        // BTC: $60,000
        btcOracle = await MockV3Aggregator.deploy(8, 6000000000000n);

        const OracleAggregator = await ethers.getContractFactory("OracleAggregator");
        oracleAggregator = await OracleAggregator.deploy();
        await oracleAggregator.setOracleConfig(wbtc.target, btcOracle.target, ethers.ZeroAddress, ethers.ZeroHash, 500);

        const CollateralManager = await ethers.getContractFactory("CollateralManager");
        collateralManager = await CollateralManager.deploy(oracleAggregator.target);

        const JUBLBoost = await ethers.getContractFactory("JUBLBoost");
        jublBoost = await JUBLBoost.deploy(jubl.target);
        await collateralManager.setJUBLBoost(jublBoost.target);

        const JubileeLending = await ethers.getContractFactory("JubileeLending");
        jubileeLending = await JubileeLending.deploy(collateralManager.target, ethers.ZeroAddress, usdi.target, owner.address);

        await collateralManager.setCollateralFactor(wbtc.target, ethers.parseEther("0.75"));

        await wbtc.mint(attacker.address, ethers.parseUnits("1", 18));
        await jubl.mint(attacker.address, ethers.parseUnits("5000", 18));
        await usdi.mint(jubileeLending.target, ethers.parseUnits("1000000", 18));
    });

    it("FIX VERIFIED: JUBL Unstaking should fail if loan becomes unhealthy", async function () {
        // Set the lending contract in JUBLBoost
        await jublBoost.setLendingContract(jubileeLending.target);

        // 1. Attacker stakes 5000 JUBL (+10% CF = 85%)
        await jubl.connect(attacker).approve(jublBoost.target, ethers.parseUnits("5000", 18));
        await jublBoost.connect(attacker).stake(ethers.parseUnits("5000", 18));

        // 2. Attacker deposits 1 BTC ($60,000)
        await wbtc.connect(attacker).approve(jubileeLending.target, ethers.parseUnits("1", 18));
        await jubileeLending.connect(attacker).depositCollateral(wbtc.target, ethers.parseUnits("1", 18));

        // 3. Attacker borrows $50,000 (Allowed because CF is 85%, max borrow is $51,000)
        await jubileeLending.connect(attacker).borrow(1, ethers.parseUnits("50000", 18));

        // 4. Attacker tries to UNSTAKE all JUBL -> should REVERT
        await expect(jublBoost.connect(attacker).unstake(ethers.parseUnits("5000", 18)))
            .to.be.revertedWith("Unstaking would cause liquidatability");

        // 5. Verify balance is still staked
        expect(await jublBoost.stakedJUBL(attacker.address)).to.equal(ethers.parseUnits("5000", 18));
    });

    it("FIX VERIFIED: Fair Liquidation Seizure", async function () {
        // 1. User deposits 1 BTC ($60,000) and borrows $40,000. CF = 75%.
        await wbtc.connect(attacker).approve(jubileeLending.target, ethers.parseUnits("1", 18));
        await jubileeLending.connect(attacker).depositCollateral(wbtc.target, ethers.parseUnits("1", 18));
        await jubileeLending.connect(attacker).borrow(1, ethers.parseUnits("40000", 18));

        // 2. BTC Price drops slightly to $53,000.
        // $53,000 * 0.75 = $39,750. Borrowed = $40,000.
        await btcOracle.updatePrice(5300000000000n);

        const LiquidationEngine = await ethers.getContractFactory("LiquidationEngine");
        const liquidationEngine = await LiquidationEngine.deploy(jubileeLending.target, collateralManager.target);
        await jubileeLending.setLiquidationEngine(liquidationEngine.target);

        await usdi.mint(liquidator.address, ethers.parseUnits("40000", 18));
        await usdi.connect(liquidator).approve(jubileeLending.target, ethers.parseUnits("40000", 18));

        // 3. Liquidate
        // Debt = $40,000. Bonus = 5% ($2,000). Total to seize = $42,000.
        // BTC Price = $53,000.
        // BTC to seize = $42,000 / $53,000 = 0.79245... BTC.
        await liquidationEngine.connect(liquidator).liquidate(1, ethers.parseUnits("40000", 18));

        // 4. Verify Liquidator only got the specified amount
        const btcBalance = await wbtc.balanceOf(liquidator.address);
        const expectedSeizure = (42000n * 10n ** 18n) / 53000n;

        // Check with small delta due to rounding
        expect(btcBalance).to.be.closeTo(expectedSeizure, ethers.parseUnits("0.0001", 18));

        // 5. Verify Borrower still has leftover collateral
        const loan = await jubileeLending.loans(1);
        expect(loan.collateralAmount).to.be.greaterThan(0);
        expect(loan.active).to.be.true;
    });
});
